# Architecture

## 1. Purpose

This document outlines the high-level architecture for the Weather Station system. It provides a conceptual overview of the components, data flows, and design considerations to guide development and future evolution.

## 2. Goals and Non-Goals

**Goals:**

- Support multiple weather station devices reporting data.
- Initially support a single user with private access to their data.
- Achieve reliable data ingestion with minimal data loss, balancing reliability and resource constraints.
- Enable flexible data ingestion intervals, starting around 60 seconds, with potential to adjust to 10 seconds or 5 minutes based on device energy and user needs.
- Use device-generated event identifiers to ensure idempotent data processing.
- Provide a private web dashboard for data visualization in the initial release.
- Plan for data aggregation such as time-bucketed summaries for efficient querying.
- Devices may use a local buffer (and optionally external storage) to reduce data loss during connectivity issues.

**Non-Goals:**

- Immediate support for multi-user sharing or collaboration is not included in the first iteration but is planned for future development.
- Zero data loss at any cost; some loss is acceptable given constraints.
- Vendor-specific dependencies or technologies.
- Fully implemented aggregation features in the first iteration.
- Complex authentication or authorization mechanisms at initial launch.

## 3. System Context

```mermaid
flowchart LR
    Device[Weather Station Device(s)]
    EdgeAPI[Edge API]
    Database[(Database)]
    Dashboard[Web Dashboard]
    User[User]

    Device -->|Event Data + event_id| EdgeAPI
    EdgeAPI -->|Store Data| Database
    User -->|Access Data| Dashboard
    Dashboard -->|Query Data| Database
```

The system consists of multiple weather station devices sending event data with unique event IDs to an Edge API. The API stores data in a central database. A web dashboard allows the user to access and visualize their data privately.

## 4. Core Components

- **Weather Station Device(s):** Generate sensor data and assign unique event identifiers for each data point.
- **Edge API:** Receives data from devices, ensures idempotency using event IDs, and stores data in the database.
- **Database:** Central storage for raw and aggregated weather data.
- **Web Dashboard:** Private user interface to view and analyze weather data.
- **Authentication Module (Future):** Planned for securing dashboard access beyond the initial simple private access.

## 5. Key Data Flows

- Devices periodically send sensor readings with event IDs to the Edge API.
- Devices maintain a local buffer and retry sending events until acknowledged, within practical limits.
- Edge API validates and stores data, avoiding duplicates via event IDs.
- Dashboard queries the database to retrieve and display data to the user.
- Aggregation processes (planned) will summarize data into time buckets for efficient reporting.

## 6. Data Model (Conceptual)

- **Event:** Represents a single sensor reading with attributes such as:
  - `event_id` (unique identifier generated by device)
  - Timestamp
  - Device identifier
  - Sensor measurements (temperature, humidity, etc.)
- **Device:** Metadata about each weather station device.
- **Aggregated Data (planned):** Summarized metrics over defined time intervals.

## 7. Security Model (Conceptual)

- Initial dashboard access is private and restricted to a single user without formal authentication.
- Data transmitted from devices to the Edge API should be protected to prevent tampering or spoofing (e.g., using secure channels).
- Future iterations will introduce authentication and authorization mechanisms for user access control.
- Future sharing is expected to be implemented as secure, authorized read-only links (token-based or similarly scoped access).
- Database access is limited to trusted backend components.

## 8. Evolution Path

- Introduce user authentication and multi-user support.
- Implement aggregation and summarization features for scalable data analysis, initially via scheduled aggregation jobs.
- Optimize ingestion frequency dynamically based on device energy and user preferences.
- Enhance reliability and error handling to minimize data loss, including local buffering and optional external storage on devices.
- Add sharing and collaboration features for multi-user scenarios, including read-only sharing links.

## 9. Open Questions

- What are the optimal buffer sizing and retention policies on devices?
- What are the conceptual specifics of the share-link authorization model?
- What is the appropriate aggregation cadence and latency trade-off?
- How should the ingestion interval strategy balance timeliness and device constraints?
